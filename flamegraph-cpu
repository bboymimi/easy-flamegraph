#!/bin/bash

APPEND_STRINGS=""
CHK_PKG=""
CPU_THRESHOLD=0
CPU_UTILIZATION=
DIGIT="^[0-9]+$"
FPATH=`dirname $0`"/"
FPERF="`dirname $0`/perf-output"
GREP_STRINGS=""
IDLE_RATE=
KEEP_SVG=false
KEEP_SVG_OPTION=
ONESHOT=false
PER_CPU_FLAMEGRAPH=
PERF_CMD=""
PERF_DATA="perf.cpu"
PERF_DATA_FINAL=""
PERF_TMP_CMD=""
PFOLDED_SUM="${FPERF}/stack_sum"
PFOLDED_SUM_FINAL="${FPERF}/callstack_sum_final"
PFOLDED_SUM_FINAL_SVG="${FPERF}/callstack_sum_final.svg"
PID=""
PROBE_POINTS=""
REP=1
RSS=""
SLEEP_TIME="3"
SRATE=99
SUBTITLE=""
TAR=false
TITLE="CPU Utilization Framegraph"

declare -A stack_array

usage_function() {
	echo "usage: `basename $0` OPTIONS VALUE"
	echo
	echo "example: `basename $0` -a <append string> -g <partial process name for pgrep > -p <process ID>"
	echo
	echo "OPTIONS:"
	echo "	-a - append process name strings"
	echo "	  to append specific strings e.g., qemu/compiz, to easily differentiate perf.data"
	echo "	-g - grep strings"
	echo "	  to grep specific strings e.g., qemu, to profile"
	echo "	-o - output file directory"
	echo "	  specificy the output file direcotry for .svg/perf.script/folded stack"
	echo "	-p, --pid - process id strings"
	echo "	  to profile the specific process"
	echo "	--clean-probes - clean the probe points"
	echo "	  clean all the inserted probe points"
	echo "	--cpu-threshold - CPU utilization threshold"
	echo "	  The CPU utilization threshold to start the sampling"
	echo "	--keep-svg - clean up all the intermediate files except svg"
	echo "	  clean up the perf intermediate files and keep on the .svg flamegraph"
	echo "	--per-cpu-flamegraph - generate the per-cpu flamegraph"
	echo "	  Generate the per-cpu flamegraph from the perf script result"
	echo "	--sample-rate - the sample rate given to perf"
	echo "	  the default sample rate given to 'perf record -F xxx'. It's 99 by default to"
	echo "	  minimize the data size. The size is limited by /proc/sys/kernel/perf_event_max_sample_rate"
}

required_tools_checking() {

	# return 1 if the specified package is installed, else return 0
	CHK_PKG=$(dpkg-query -W -f='${Status}' $1 2>/dev/null | grep -c "ok installed")
	[ $CHK_PKG -eq 0 ] && apt-get install -y $1
}

clean_probe_points() {
	echo "Clean up the probe points before starting the profiling..."
	PROBE_POINTS=$(perf probe -l | awk '{print $1}')
	for i in $PROBE_POINTS; do
	perf probe -d $i
	done
}

perf_periodically_collect() {
	PERF_TMP_CMD="perf record $KMEM_APPEND $GLIBC_APPEND $TCMALLOC_APPEND -a -F $SRATE --call-graph dwarf"

	[[ $PID != "" ]] && PERF_TMP_CMD="$PERF_TMP_CMD -p $PID"
	[[ $GREP_STRINGS != "" ]] && PERF_TMP_CMD="$PERF_TMP_CMD -p `pgrep $GREP_STRINGS`"

	while true; do
		IDLE_RATE=$(mpstat -P ON 1 1| grep -P 'Average:\s+all'| perl -n -e '/Average:\s+all.+\s(\d+)\.(\d+)$/; print $1;')
		echo IDLE_RATE:$IDLE_RATE
		((CPU_UTILIZATION = 100 - "$IDLE_RATE"))
		if [[ "$CPU_UTILIZATION" -lt "$CPU_THRESHOLD" ]]; then
			echo "CPU_UTILIZATION:$CPU_UTILIZATION < CPU_THRESHOLD:$CPU_THRESHOLD !!"
			if $ONESHOT; then
				break;
			fi
			sleep 58
			continue;
		fi

		DATE=$(date +%Y-%m-%d_%H%M%S)

		PERF_DATA_FINAL=${FPERF}/${DATE}.${PERF_DATA}.t${CPU_THRESHOLD}.u${CPU_UTILIZATION}.${REP}

		if ! $ONESHOT; then
		       clear
		fi

		# press ctrl+c when you want to stop the profiling
		PERF_CMD="$PERF_TMP_CMD -o $PERF_DATA_FINAL sleep 1"

		echo "###########"
		echo "# CMD: $PERF_CMD"
		echo "# The Perf file will be generated to \"$PERF_DATA_FINAL\""
		echo "# Profiling..."
		echo "###########"

		# Profiling the system
		$PERF_CMD &> /dev/null || break

		SUBTITLE="${DATE} CPU Threshold:${CPU_THRESHOLD}% CPU Utilization:${CPU_UTILIZATION}%"
		(
			# Generate the flamegraph
			"${FPATH}"/easy-flamegraph.sh -i "$PERF_DATA_FINAL" "$KEEP_SVG_OPTION" -o "$FPERF" \
			       --title "${TITLE}" --subtitle "${SUBTITLE}" "$PER_CPU_FLAMEGRAPH" &> /dev/null

			# clean up the perf.data
			if $KEEP_SVG; then
				rm $PERF_DATA_FINAL
			else
				if [ -e "$FPERF"/`basename "$PERF_DATA_FINAL"`.zip ]; then
					echo "Append $PERF_DATA_FINAL to "$FPERF"/`basename "$PERF_DATA_FINAL"`.zip"
					# tar.gz is generated by easy-flamegraph.sh and append the perf.data in.
					zip -u "$FPERF"/`basename "$PERF_DATA_FINAL"`.zip "$PERF_DATA_FINAL"
					rm $PERF_DATA_FINAL
				fi

			fi
		) &

		if $ONESHOT; then
		       break;
		fi

		sleep 58

		((REP++))
	done

	if ! $ONESHOT; then
		(
			# Generate the flamegraph
			"${FPATH}"/easy-flamegraph.sh -i $PERF_DATA_FINAL $KEEP_SVG_OPTION -o "$FPERF" \
			       --title "${TITLE}" --subtitle "${SUBTITLE}" "$PER_CPU_FLAMEGRAPH" &> /dev/null

			# clean up the perf.data
			if $KEEP_SVG; then
				rm $PERF_DATA_FINAL
			fi
		) &
	fi

	# wait for all the easy-flamegraph.sh child processes to complete
	echo "wait for easy-flamegraph to finish processing and compressing..."
	wait
}

merge_all_flamegraphs() {
	# rm the PFOLDED_SUM if exist to avoid the overlay of previous time
	[ ! -s ${PFOLDED_SUM} ] && echo "Aggregated graph is empty! No perf data captured!" && return

	DATE=$(date +%Y-%m-%d_%H%M%S)

	NAME=${DATE}
	[[ $APPEND_STRINGS != "" ]] && NAME=${NAME}.${APPEND_STRINGS}
	[[ $PID != "" ]] && NAME=${NAME}.${PID}

	# recalculate the counts make the summarized flamegraph
	while read -r callstack_counts; do
		counts=$(echo $callstack_counts |perl -n -e '/(\d)+$/; print $&;')
		callstack=$(echo $callstack_counts |perl -n -e '/(.*) (\d)+$/; print $1;')
		stack_array[$callstack]=$((${stack_array[$callstack]} + $counts))
	done < ${PFOLDED_SUM}

	[ -f "${PFOLDED_SUM_FINAL}" ] && rm "${PFOLDED_SUM_FINAL}"
	for stack in "${!stack_array[@]}"; do
		echo "$stack ${stack_array[$stack]}" >> "$PFOLDED_SUM_FINAL"
	done

	cat "$PFOLDED_SUM_FINAL" | ${FPATH}flamegraph.pl > "$PFOLDED_SUM_FINAL_SVG"
}

clean_intermediate_files() {
	[ -f "${PFOLDED_SUM}" ] && rm "${PFOLDED_SUM}"
	[ -f "${PFOLDED_SUM_FINAL}" ] && rm "${PFOLDED_SUM_FINAL}"
}
[ $(id -u) -ne 0 ] && echo "Must be root!!" && exit 1

kill_child_processes() {

    local isTopmost=$1
    local curPid=$2
    local childPid

    childPids=`ps -o pid --no-headers --ppid ${curPid}`
    # echo child of ${curPid}: ${childPids}

    for childPid in $childPids; do
        kill_child_processes 0 $childPid
    done

    if [ $isTopmost -eq 0 ]; then
        # echo kill -9 $curPid
	kill -9 $curPid &> /dev/null
    fi
}

exit_work() {

	# clean the probe point after profiling the system
	clean_probe_points

	# merge all flamegraphs to form a bigger picture
	# TODO: disable the merge_all_flamegraphs temporarily until better
	# ideas come.

	# merge_all_flamegraphs

	# clean up all the intermediate files
	[ $KEEP_SVG ] && clean_intermediate_files

	kill_child_processes 1 $$

	# kill -9 $(ps -9 pgid= $$) can do the trick to kill the process group too.
	#PGID=$(ps -o pgid= $$)

	## Kill needs to be done in a new process group to avoid killing itself.
	#setsid kill -- -$PGID

	exit 0
}

while (($# > 0))
do
	case $1 in
		-a)
			APPEND_STRINGS=$2
			shift 2
			;;
		-g)
			GREP_STRINGS=$2
			shift 2
			;;
		-o)
			FPERF=$2
			shift 2
			;;
		-p|--pid)
			PID=$2
			shift 2
			;;
		-t)
			TAR=true
			KEEP_SVG_OPTION="-t"
			shift
			;;
		--clean-probes)
			clean_probe_points
			exit 0
			;;
		--cpu-threshold)
			CPU_THRESHOLD=$2
			shift 2
			;;
		--keep-svg)
			KEEP_SVG=true
			KEEP_SVG_OPTION="-d"
			shift
			;;
		--per-cpu-flamegraph)
			PER_CPU_FLAMEGRAPH="--per-cpu-flamegraph"
			shift
			;;
		--oneshot)
			ONESHOT=true
			shift
			;;
		--sample-rate)
			SRATE=$2
			shift 2
			;;
		-h|--help)
			usage_function
			exit 0
			;;
		*)
			echo "Error!! Invalid input: $1"
			usage_function
			exit 1
			;;
	esac
done

# -t is to tar the intermediate files which is conflicted with the --keep-svg
# which keeps only the .svg file
[[ "$TAR" == "true" ]] && [[ "$KEEP_SVG" == "true" ]] && echo "Cannot set '-t' and '--keep-svg' together!" && exit 1

# append the string of the profiled process name to differentiate the perf.data
[[ "$APPEND_STRINGS" != "" ]] && PERF_DATA=$PERF_DATA.$APPEND_STRINGS$PID

# clean up the perf-output
[ "$(ls $FPERF)" != "" -a "$ONESHOT" = "false" ] && rm $FPERF/* && echo "clean up the perf data successfully!!"

mkdir -p $FPERF

#trap EXIT signal only
trap "exit_work" EXIT

# check if the required tool(s) is installed. e.g. linux-tools-common.
required_tools_checking linux-tools-common
required_tools_checking sysstat

# clean the probe point before adding the new probe point
clean_probe_points

# collect the perf data periodically in case the perf file gets too big
perf_periodically_collect &

if ! $ONESHOT; then
	sleep 1
	# press any key to quit
	read -p $'Press any keys to quit...\n'
else
	# wait for the children's collection to stop
	wait
fi
